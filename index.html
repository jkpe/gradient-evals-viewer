<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evaluation Viewer</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Proxima Nova', 'ProximaNova', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #f5f7fa;
            color: #1a1a1a;
            line-height: 1.6;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 24px;
            color: #1a1a1a;
        }

        .upload-section {
            background: white;
            border-radius: 8px;
            padding: 24px;
            margin-bottom: 24px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .upload-section label {
            display: block;
            font-weight: 600;
            margin-bottom: 12px;
            font-size: 14px;
            color: #4a5568;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
        }

        .file-input-wrapper input[type="file"] {
            width: 100%;
            padding: 12px;
            border: 2px dashed #cbd5e0;
            border-radius: 6px;
            background: #f7fafc;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .file-input-wrapper input[type="file"]:hover {
            border-color: #4299e1;
            background: #ebf8ff;
        }

        .metadata-section {
            background: white;
            border-radius: 8px;
            padding: 24px;
            margin-bottom: 24px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            display: none;
        }

        .metadata-section.visible {
            display: block;
        }

        .metadata-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 16px;
            margin-top: 16px;
        }

        .metadata-item {
            padding: 12px;
            background: #f7fafc;
            border-radius: 6px;
        }

        .metadata-label {
            font-size: 12px;
            font-weight: 600;
            color: #718096;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .metadata-value {
            font-size: 14px;
            color: #2d3748;
            font-weight: 500;
        }

        .pass-status {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .pass-status.true {
            background: #c6f6d5;
            color: #22543d;
        }

        .pass-status.false {
            background: #fed7d7;
            color: #742a2a;
        }

        .prompts-container {
            display: none;
        }

        .prompts-container.visible {
            display: block;
        }

        .prompt-card {
            background: white;
            border-radius: 8px;
            padding: 24px;
            margin-bottom: 24px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            transition: box-shadow 0.2s;
        }

        .prompt-card:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .prompt-header {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 20px;
            color: #2d3748;
            padding-bottom: 12px;
            border-bottom: 2px solid #e2e8f0;
        }

        .prompt-header-title {
            margin-right: auto;
        }

        .metric-badge {
            display: inline-flex;
            align-items: center;
            padding: 4px 10px;
            background: #edf2f7;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            color: #4a5568;
            white-space: nowrap;
        }

        .metric-badge-name {
            margin-right: 4px;
            color: #718096;
        }

        .metric-badge-value {
            color: #2d3748;
            font-weight: 700;
        }

        .metric-badge[data-metric-color] {
            background: var(--metric-bg);
            color: var(--metric-text);
        }

        .metric-badge[data-metric-color] .metric-badge-name {
            color: var(--metric-text);
            opacity: 0.8;
        }

        .metric-badge[data-metric-color] .metric-badge-value {
            color: var(--metric-text);
        }

        .prompt-section {
            margin-bottom: 20px;
        }

        .prompt-section-label {
            font-size: 12px;
            font-weight: 600;
            color: #718096;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .prompt-content {
            background: #f7fafc;
            padding: 16px;
            border-radius: 6px;
            border-left: 3px solid #4299e1;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: 14px;
            line-height: 1.7;
            color: #2d3748;
        }

        .prompt-content.markdown {
            white-space: normal;
        }

        .prompt-content.markdown h1,
        .prompt-content.markdown h2,
        .prompt-content.markdown h3,
        .prompt-content.markdown h4,
        .prompt-content.markdown h5,
        .prompt-content.markdown h6 {
            margin: 16px 0 8px 0;
            font-weight: 600;
            color: #1a202c;
        }

        .prompt-content.markdown h1 {
            font-size: 20px;
        }

        .prompt-content.markdown h2 {
            font-size: 18px;
        }

        .prompt-content.markdown h3 {
            font-size: 16px;
        }

        .prompt-content.markdown p {
            margin: 8px 0;
        }

        .prompt-content.markdown ul,
        .prompt-content.markdown ol {
            margin: 8px 0;
            padding-left: 24px;
        }

        .prompt-content.markdown li {
            margin: 4px 0;
        }

        .prompt-content.markdown strong,
        .prompt-content.markdown b {
            font-weight: 600;
            color: #2d3748;
        }

        .prompt-content.markdown em,
        .prompt-content.markdown i {
            font-style: italic;
        }

        .prompt-content.markdown code {
            background: #edf2f7;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 13px;
        }

        .prompt-content.markdown pre {
            background: #2d3748;
            color: #e2e8f0;
            padding: 12px;
            border-radius: 6px;
            overflow-x: auto;
            margin: 12px 0;
        }

        .prompt-content.markdown pre code {
            background: transparent;
            padding: 0;
            color: inherit;
        }

        .prompt-content.markdown a {
            color: #4299e1;
            text-decoration: none;
        }

        .prompt-content.markdown a:hover {
            text-decoration: underline;
        }

        .prompt-content.markdown hr {
            border: none;
            border-top: 1px solid #e2e8f0;
            margin: 16px 0;
        }

        .prompt-content.markdown blockquote {
            border-left: 3px solid #cbd5e0;
            padding-left: 16px;
            margin: 12px 0;
            color: #4a5568;
            font-style: italic;
        }

        .output-content {
            border-left-color: #48bb78;
        }

        .metrics-expander {
            margin-top: 20px;
        }

        .metrics-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: #edf2f7;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
            user-select: none;
        }

        .metrics-header:hover {
            background: #e2e8f0;
        }

        .metrics-title {
            font-size: 14px;
            font-weight: 600;
            color: #4a5568;
        }

        .metrics-toggle {
            font-size: 20px;
            color: #718096;
            transition: transform 0.3s;
        }

        .metrics-toggle.expanded {
            transform: rotate(180deg);
        }

        .metrics-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .metrics-content.expanded {
            max-height: 5000px;
            transition: max-height 0.5s ease-in;
        }

        .metrics-list {
            padding: 16px;
            background: #f7fafc;
            border-radius: 6px;
            margin-top: 8px;
        }

        .metric-item {
            background: white;
            padding: 16px;
            border-radius: 6px;
            margin-bottom: 12px;
            border-left: 3px solid #9f7aea;
        }

        .metric-item:last-child {
            margin-bottom: 0;
        }

        .metric-name {
            font-size: 16px;
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 8px;
        }

        .metric-value {
            font-size: 24px;
            font-weight: 700;
            color: #4299e1;
            margin-bottom: 4px;
        }

        .metric-type {
            font-size: 12px;
            color: #718096;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .metric-reasoning {
            font-size: 13px;
            color: #4a5568;
            line-height: 1.6;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #e2e8f0;
            white-space: pre-wrap;
        }

        .metric-error {
            font-size: 13px;
            color: #e53e3e;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #e2e8f0;
            font-style: italic;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #718096;
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }

        .empty-state-text {
            font-size: 16px;
        }

        .score-filter-section {
            background: white;
            border-radius: 8px;
            padding: 24px;
            margin-bottom: 24px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            display: none;
        }

        .score-filter-section.visible {
            display: block;
        }

        .score-filter-section h2 {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 16px;
            color: #2d3748;
        }

        .score-matrix-container {
            overflow-x: auto;
            margin-bottom: 20px;
        }

        .score-matrix {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
            min-width: 600px;
        }

        .score-matrix th,
        .score-matrix td {
            padding: 8px 12px;
            text-align: left;
            border: 1px solid #e2e8f0;
        }

        .score-matrix th {
            background: #f7fafc;
            font-weight: 600;
            color: #2d3748;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .score-matrix th:first-child {
            position: sticky;
            left: 0;
            background: #f7fafc;
            z-index: 11;
        }

        .score-matrix td:first-child {
            position: sticky;
            left: 0;
            background: white;
            z-index: 9;
            font-weight: 600;
        }

        .score-matrix tbody tr:hover {
            background: #f7fafc;
        }

        .score-matrix tbody tr:hover td:first-child {
            background: #f7fafc;
        }

        .score-matrix .prompt-link {
            color: #4299e1;
            cursor: pointer;
            text-decoration: none;
            transition: color 0.2s;
        }

        .score-matrix .prompt-link:hover {
            color: #2c5282;
            text-decoration: underline;
        }

        .score-cell {
            text-align: center;
            font-weight: 500;
        }

        .score-cell.empty {
            color: #cbd5e0;
        }

        .filter-checkboxes {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 16px;
        }

        .filter-checkbox-item {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            background: #f7fafc;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .filter-checkbox-item:hover {
            background: #edf2f7;
        }

        .filter-checkbox-item input[type="checkbox"] {
            margin-right: 8px;
            cursor: pointer;
        }

        .filter-checkbox-item label {
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #2d3748;
            margin: 0;
        }

        .filter-checkbox-item input[type="checkbox"]:checked + label {
            color: #4299e1;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>DigitalOcean Gradient™ AI Platform Evaluation Viewer</h1>

        <div class="upload-section">
            <label for="jsonFile">Upload JSON Evaluation File</label>
            <div class="file-input-wrapper">
                <input type="file" id="jsonFile" accept=".json" />
            </div>
        </div>

        <div id="scoreFilterSection" class="score-filter-section">
            <h2>Score Matrix & Filters</h2>
            <div class="score-range-filters">
                <h3 style="font-size: 18px; font-weight: 600; margin-bottom: 12px; color: #2d3748;">Filter by Score Range</h3>
                <div class="filter-checkboxes" id="scoreRangeFilters">
                    <div class="filter-checkbox-item">
                        <input type="checkbox" id="score-range-poor" data-range="poor" checked>
                        <label for="score-range-poor" style="color: #742A2A;">Poor (< 60)</label>
                    </div>
                    <div class="filter-checkbox-item">
                        <input type="checkbox" id="score-range-medium" data-range="medium" checked>
                        <label for="score-range-medium" style="color: #744210;">Medium (60-90)</label>
                    </div>
                    <div class="filter-checkbox-item">
                        <input type="checkbox" id="score-range-good" data-range="good" checked>
                        <label for="score-range-good" style="color: #22543D;">Good (≥ 90)</label>
                    </div>
                </div>
            </div>
            <div class="metric-filters">
                <h3 style="font-size: 18px; font-weight: 600; margin-bottom: 12px; color: #2d3748; margin-top: 20px;">Filter by Metric</h3>
                <div class="filter-checkboxes" id="filterCheckboxes"></div>
            </div>
            <div class="score-matrix-container">
                <table id="scoreMatrix" class="score-matrix"></table>
            </div>
        </div>

        <div id="metadataSection" class="metadata-section">
            <h2 style="font-size: 24px; font-weight: 600; margin-bottom: 16px; color: #2d3748;">Evaluation Run Metadata</h2>
            <div id="metadataContent" class="metadata-grid"></div>
        </div>

        <div id="promptsContainer" class="prompts-container">
            <div id="promptsList"></div>
        </div>

        <div id="emptyState" class="empty-state">
            <div class="empty-state-icon">📄</div>
            <div class="empty-state-text">Upload a JSON file to view evaluation data</div>
        </div>
    </div>

    <script>
        const fileInput = document.getElementById('jsonFile');
        const metadataSection = document.getElementById('metadataSection');
        const metadataContent = document.getElementById('metadataContent');
        const promptsContainer = document.getElementById('promptsContainer');
        const promptsList = document.getElementById('promptsList');
        const emptyState = document.getElementById('emptyState');
        const scoreFilterSection = document.getElementById('scoreFilterSection');
        const scoreMatrix = document.getElementById('scoreMatrix');
        const filterCheckboxes = document.getElementById('filterCheckboxes');
        const scoreRangeFilters = document.getElementById('scoreRangeFilters');

        let allPrompts = [];
        let selectedMetricFilters = new Set();
        let selectedScoreRanges = new Set(['poor', 'medium', 'good']); // All selected by default

        fileInput.addEventListener('change', handleFileUpload);

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    displayEvaluationData(data);
                } catch (error) {
                    alert('Error parsing JSON file: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        function displayEvaluationData(data) {
            // Hide empty state
            emptyState.style.display = 'none';

            // Display metadata if available
            if (data.evaluation_run) {
                displayMetadata(data.evaluation_run);
                metadataSection.classList.add('visible');
            }

            // Store prompts and build score matrix
            if (data.prompts && Array.isArray(data.prompts)) {
                allPrompts = data.prompts;
                buildScoreMatrix(data.prompts, data.prompts);
                buildFilterCheckboxes(data.prompts);
                setupScoreRangeFilters();
                scoreFilterSection.classList.add('visible');
                displayPrompts(data.prompts);
                promptsContainer.classList.add('visible');
            }
        }

        function displayMetadata(evalRun) {
            const metadata = [
                { label: 'Run Name', value: evalRun.run_name || 'N/A' },
                { label: 'Status', value: evalRun.status || 'N/A' },
                { label: 'Test Case', value: evalRun.test_case_name || 'N/A' },
                { label: 'Agent Name', value: evalRun.agent_name || 'N/A' },
                { label: 'Pass Status', value: evalRun.pass_status !== undefined ? String(evalRun.pass_status) : 'N/A', isStatus: true },
                { label: 'Started At', value: evalRun.started_at || 'N/A' },
                { label: 'Finished At', value: evalRun.finished_at || 'N/A' },
            ];

            if (evalRun.star_metric_result) {
                metadata.push({
                    label: 'Star Metric',
                    value: `${evalRun.star_metric_result.metric_name || 'N/A'}: ${formatMetricValue(evalRun.star_metric_result)}`
                });
            }

            metadataContent.innerHTML = metadata.map(item => {
                let valueHtml = item.value;
                if (item.isStatus) {
                    const statusClass = item.value === 'true' ? 'true' : 'false';
                    valueHtml = `<span class="pass-status ${statusClass}">${item.value}</span>`;
                }
                return `
                    <div class="metadata-item">
                        <div class="metadata-label">${item.label}</div>
                        <div class="metadata-value">${valueHtml}</div>
                    </div>
                `;
            }).join('');
        }

        function displayPrompts(prompts) {
            // Filter prompts based on selected metric filters
            const filteredPrompts = filterPromptsByMetrics(prompts);
            
            promptsList.innerHTML = filteredPrompts.map(prompt => createPromptCard(prompt)).join('');
            
            // Add ID and data attribute to each prompt card for filtering and scrolling
            document.querySelectorAll('.prompt-card').forEach((card, index) => {
                const promptId = filteredPrompts[index].prompt_id;
                card.setAttribute('id', `prompt-${promptId}`);
                card.setAttribute('data-prompt-id', promptId);
            });
            
            // Attach event listeners to expanders
            document.querySelectorAll('.metrics-header').forEach(header => {
                header.addEventListener('click', function() {
                    const content = this.nextElementSibling;
                    const toggle = this.querySelector('.metrics-toggle');
                    content.classList.toggle('expanded');
                    toggle.classList.toggle('expanded');
                });
            });
        }

        function buildScoreMatrix(prompts, allPromptsForHeaders) {
            // Use all prompts to collect all unique metric names for headers
            // This ensures the table shows all possible metrics even if filtered
            const promptsForHeaders = allPromptsForHeaders || prompts;
            const metricNames = new Set();
            promptsForHeaders.forEach(prompt => {
                if (prompt.prompt_level_metric_results) {
                    prompt.prompt_level_metric_results.forEach(metric => {
                        if (metric.metric_name) {
                            metricNames.add(metric.metric_name);
                        }
                    });
                }
            });

            const sortedMetricNames = Array.from(metricNames).sort();

            // Build table header
            let html = '<thead><tr><th>Prompt</th>';
            sortedMetricNames.forEach(metricName => {
                html += `<th>${escapeHtml(metricName)}</th>`;
            });
            html += '</tr></thead>';

            // Build table body using filtered prompts
            html += '<tbody>';
            prompts.forEach(prompt => {
                html += `<tr><td><a href="#prompt-${prompt.prompt_id}" class="prompt-link" data-prompt-id="${prompt.prompt_id}">Prompt #${prompt.prompt_id}</a></td>`;
                
                sortedMetricNames.forEach(metricName => {
                    const metric = prompt.prompt_level_metric_results?.find(m => m.metric_name === metricName);
                    if (metric && metric.number_value !== undefined && metric.number_value !== null) {
                        const value = metric.metric_value_type === 'METRIC_VALUE_TYPE_PERCENTAGE'
                            ? `${metric.number_value.toFixed(0)}%`
                            : metric.number_value.toString();
                        const color = getScoreColor(metric.number_value);
                        html += `<td class="score-cell" style="background-color: ${color.bg}; color: ${color.text};">${value}</td>`;
                    } else {
                        html += '<td class="score-cell empty">—</td>';
                    }
                });
                html += '</tr>';
            });
            html += '</tbody>';

            scoreMatrix.innerHTML = html;

            // Add click handlers to prompt links
            scoreMatrix.querySelectorAll('.prompt-link').forEach(link => {
                link.addEventListener('click', function(e) {
                    e.preventDefault();
                    const promptId = this.getAttribute('data-prompt-id');
                    scrollToPrompt(promptId);
                });
            });
        }

        function buildFilterCheckboxes(prompts) {
            // Collect all unique metric names
            const metricNames = new Set();
            prompts.forEach(prompt => {
                if (prompt.prompt_level_metric_results) {
                    prompt.prompt_level_metric_results.forEach(metric => {
                        if (metric.metric_name) {
                            metricNames.add(metric.metric_name);
                        }
                    });
                }
            });

            const sortedMetricNames = Array.from(metricNames).sort();

            // Build checkboxes - all checked by default
            filterCheckboxes.innerHTML = sortedMetricNames.map(metricName => {
                const checkboxId = `filter-${metricName.replace(/[^a-zA-Z0-9]/g, '-')}`;
                selectedMetricFilters.add(metricName); // Add all by default
                return `
                    <div class="filter-checkbox-item">
                        <input type="checkbox" id="${checkboxId}" data-metric="${escapeHtml(metricName)}" checked>
                        <label for="${checkboxId}">${escapeHtml(metricName)}</label>
                    </div>
                `;
            }).join('');

            // Add event listeners to checkboxes
            filterCheckboxes.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    const metricName = this.getAttribute('data-metric');
                    if (this.checked) {
                        selectedMetricFilters.add(metricName);
                    } else {
                        selectedMetricFilters.delete(metricName);
                    }
                    // Update both prompts and score matrix with new filter
                    updateFilteredResults();
                });
            });
        }

        function setupScoreRangeFilters() {
            // Add event listeners to score range checkboxes
            scoreRangeFilters.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    const range = this.getAttribute('data-range');
                    if (this.checked) {
                        selectedScoreRanges.add(range);
                    } else {
                        selectedScoreRanges.delete(range);
                    }
                    // Update both prompts and score matrix with new filter
                    updateFilteredResults();
                });
            });
        }

        function updateFilteredResults() {
            // Get filtered prompts
            const filteredPrompts = filterPromptsByMetrics(allPrompts);
            
            // Update both the score matrix and the prompt cards
            buildScoreMatrix(filteredPrompts, allPrompts);
            displayPrompts(allPrompts); // displayPrompts will filter internally via filterPromptsByMetrics
        }

        function getScoreRange(score) {
            if (score < 60) {
                return 'poor';
            } else if (score < 90) {
                return 'medium';
            } else {
                return 'good';
            }
        }

        function scrollToPrompt(promptId) {
            // Try to find the prompt card - it might be filtered out
            let promptCard = document.getElementById(`prompt-${promptId}`);
            
            // If the prompt is not visible (filtered out), find it in allPrompts and make sure it's shown
            if (!promptCard) {
                // Find the prompt in allPrompts
                const prompt = allPrompts.find(p => p.prompt_id === parseInt(promptId));
                if (prompt && prompt.prompt_level_metric_results) {
                    // Add all metrics from this prompt to the selected filters
                    prompt.prompt_level_metric_results.forEach(metric => {
                        if (metric.metric_name) {
                            selectedMetricFilters.add(metric.metric_name);
                            // Also update the checkbox - find it by checking all metric checkboxes
                            filterCheckboxes.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                                if (checkbox.getAttribute('data-metric') === metric.metric_name) {
                                    checkbox.checked = true;
                                }
                            });
                        }
                        
                        // Also ensure the score range for this metric is selected
                        if (metric.number_value !== undefined && metric.number_value !== null) {
                            const range = getScoreRange(metric.number_value);
                            selectedScoreRanges.add(range);
                            // Update the score range checkbox
                            const rangeCheckbox = scoreRangeFilters.querySelector(`input[data-range="${range}"]`);
                            if (rangeCheckbox) {
                                rangeCheckbox.checked = true;
                            }
                        }
                    });
                    
                    // Re-display prompts with updated filters
                    displayPrompts(allPrompts);
                    
                    // Wait a moment for DOM to update, then scroll
                    setTimeout(() => {
                        promptCard = document.getElementById(`prompt-${promptId}`);
                        if (promptCard) {
                            promptCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            highlightPromptCard(promptCard);
                        }
                    }, 100);
                    return;
                }
            }
            
            if (promptCard) {
                // Scroll to the prompt card
                promptCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                highlightPromptCard(promptCard);
            }
        }

        function highlightPromptCard(card) {
            // Highlight the prompt card briefly
            card.style.transition = 'box-shadow 0.3s ease';
            card.style.boxShadow = '0 4px 12px rgba(66, 153, 225, 0.5)';
            
            setTimeout(() => {
                card.style.boxShadow = '';
            }, 2000);
        }

        function filterPromptsByMetrics(prompts) {
            // If no filters selected, show all prompts
            const hasMetricFilter = selectedMetricFilters.size > 0;
            const hasScoreRangeFilter = selectedScoreRanges.size > 0;

            if (!hasMetricFilter && !hasScoreRangeFilter) {
                return prompts;
            }

            // Filter prompts based on selected filters
            return prompts.filter(prompt => {
                if (!prompt.prompt_level_metric_results || prompt.prompt_level_metric_results.length === 0) {
                    // If filters are active, hide prompts with no metrics
                    return false;
                }

                // Check if prompt has at least one metric that matches the filter criteria
                // If both metric and score filters are selected, the same metric must match both
                // If only one type of filter is selected, we check just that filter
                return prompt.prompt_level_metric_results.some(metric => {
                    // Check metric name filter
                    const metricNameMatches = !hasMetricFilter || 
                        (metric.metric_name && selectedMetricFilters.has(metric.metric_name));
                    
                    // Check score range filter
                    let scoreRangeMatches = !hasScoreRangeFilter;
                    if (hasScoreRangeFilter && metric.number_value !== undefined && metric.number_value !== null) {
                        const range = getScoreRange(metric.number_value);
                        scoreRangeMatches = selectedScoreRanges.has(range);
                    }
                    
                    // Metric matches if it satisfies both filters (or whichever filters are active)
                    return metricNameMatches && scoreRangeMatches;
                });
            });
        }

        function createPromptCard(prompt) {
            const metricsHtml = prompt.prompt_level_metric_results && prompt.prompt_level_metric_results.length > 0
                ? `
                    <div class="metrics-expander">
                        <div class="metrics-header">
                            <span class="metrics-title">Metric Results (${prompt.prompt_level_metric_results.length})</span>
                            <span class="metrics-toggle">▼</span>
                        </div>
                        <div class="metrics-content">
                            <div class="metrics-list">
                                ${prompt.prompt_level_metric_results.map(metric => createMetricItem(metric)).join('')}
                            </div>
                        </div>
                    </div>
                `
                : '';

            // Sort metrics by name for consistent ordering
            const sortedMetrics = prompt.prompt_level_metric_results && prompt.prompt_level_metric_results.length > 0
                ? [...prompt.prompt_level_metric_results].sort((a, b) => {
                    const nameA = (a.metric_name || '').toLowerCase();
                    const nameB = (b.metric_name || '').toLowerCase();
                    return nameA.localeCompare(nameB);
                })
                : [];

            const badgesHtml = sortedMetrics.length > 0
                ? sortedMetrics.map(metric => createMetricBadge(metric)).join('')
                : '';

            return `
                <div class="prompt-card">
                    <div class="prompt-header">
                        <span class="prompt-header-title">Prompt #${prompt.prompt_id}</span>
                        ${badgesHtml}
                    </div>
                    
                    <div class="prompt-section">
                        <div class="prompt-section-label">Input</div>
                        <div class="prompt-content">${escapeHtml(prompt.input || 'N/A')}</div>
                    </div>
                    
                    <div class="prompt-section">
                        <div class="prompt-section-label">Output</div>
                        <div class="prompt-content output-content markdown">${renderMarkdown(prompt.output || 'N/A')}</div>
                    </div>
                    
                    ${metricsHtml}
                </div>
            `;
        }

        function createMetricItem(metric) {
            const valueHtml = formatMetricValue(metric);
            const reasoningHtml = metric.reasoning 
                ? `<div class="metric-reasoning">${escapeHtml(metric.reasoning)}</div>` 
                : '';
            const errorHtml = metric.error_description
                ? `<div class="metric-error">Error: ${escapeHtml(metric.error_description)}</div>`
                : '';

            // Get color based on score if available
            let valueStyle = '';
            if (metric.number_value !== undefined && metric.number_value !== null) {
                const color = getScoreColor(metric.number_value);
                valueStyle = `style="color: ${color.text};"`;
            }

            return `
                <div class="metric-item">
                    <div class="metric-name">${escapeHtml(metric.metric_name || 'N/A')}</div>
                    <div class="metric-value" ${valueStyle}>${valueHtml}</div>
                    <div class="metric-type">${escapeHtml(metric.metric_value_type || 'N/A')}</div>
                    ${reasoningHtml}
                    ${errorHtml}
                </div>
            `;
        }

        function formatMetricValue(metric) {
            if (metric.number_value !== undefined && metric.number_value !== null) {
                if (metric.metric_value_type === 'METRIC_VALUE_TYPE_PERCENTAGE') {
                    return `${metric.number_value.toFixed(2)}%`;
                }
                return metric.number_value.toString();
            }
            return 'N/A';
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function renderMarkdown(text) {
            if (!text || text === 'N/A') return 'N/A';
            try {
                // Configure marked options
                marked.setOptions({
                    breaks: true,
                    gfm: true,
                    headerIds: false,
                    mangle: false
                });
                return marked.parse(text);
            } catch (error) {
                // Fallback to escaped text if markdown parsing fails
                return escapeHtml(text);
            }
        }

        // Color palette with 20 distinct, well-separated colors for metrics
        // Each color has a light background and dark text color for good contrast
        const metricColorPalette = [
            { bg: '#E6F3FF', text: '#0066CC' },  // Blue
            { bg: '#FFF4E6', text: '#CC6600' },  // Orange
            { bg: '#E6F7E6', text: '#006600' },  // Green
            { bg: '#F0E6FF', text: '#6600CC' },  // Purple
            { bg: '#FFE6E6', text: '#CC0000' },  // Red
            { bg: '#E6FFF0', text: '#00CC66' },  // Mint
            { bg: '#FFF0E6', text: '#CC3300' },  // Coral
            { bg: '#E6F0FF', text: '#0033CC' },  // Deep Blue
            { bg: '#FFF6E6', text: '#CC9900' }, // Amber
            { bg: '#F0E6F7', text: '#9900CC' }, // Lavender
            { bg: '#E6FFF7', text: '#00CC99' }, // Turquoise
            { bg: '#FFE6F0', text: '#CC0066' }, // Pink
            { bg: '#F7F0E6', text: '#996600' },  // Brown
            { bg: '#E6FFFA', text: '#00CCCC' },  // Cyan
            { bg: '#FFF0F0', text: '#CC3333' }, // Rose
            { bg: '#F0F7E6', text: '#669900' }, // Olive
            { bg: '#E6E6FF', text: '#6666CC' }, // Periwinkle
            { bg: '#FFF7E6', text: '#CC7700' }, // Peach
            { bg: '#F7E6FF', text: '#9900CC' }, // Lilac
            { bg: '#E6FFF5', text: '#00CC88' }  // Teal
        ];

        function getMetricColor(metricName) {
            // Generate a consistent hash from metric name
            let hash = 0;
            for (let i = 0; i < metricName.length; i++) {
                hash = metricName.charCodeAt(i) + ((hash << 5) - hash);
                hash = hash & hash; // Convert to 32-bit integer
            }
            
            // Map hash to one of the 20 colors
            const colorIndex = Math.abs(hash) % metricColorPalette.length;
            return metricColorPalette[colorIndex];
        }

        function getScoreColor(score) {
            // Color based on score ranges:
            // 0-60: red
            // 60-90: yellow
            // 90+: green
            if (score < 60) {
                return { bg: '#FED7D7', text: '#742A2A' }; // Red
            } else if (score < 90) {
                return { bg: '#FEFCBF', text: '#744210' }; // Yellow
            } else {
                return { bg: '#C6F6D5', text: '#22543D' }; // Green
            }
        }

        function createMetricBadge(metric) {
            if (metric.number_value === undefined || metric.number_value === null) {
                return '';
            }

            const value = metric.number_value;
            const valueDisplay = metric.metric_value_type === 'METRIC_VALUE_TYPE_PERCENTAGE' 
                ? `${value.toFixed(0)}%`
                : value.toString();
            
            // Get color based on score value
            const metricName = metric.metric_name || 'N/A';
            const color = getScoreColor(value);

            // Shorten metric name if too long
            const shortName = metricName.length > 20 
                ? metricName.substring(0, 18) + '...'
                : metricName;

            return `<span class="metric-badge" data-metric-color="${escapeHtml(metricName)}" style="--metric-bg: ${color.bg}; --metric-text: ${color.text};">
                <span class="metric-badge-name">${escapeHtml(shortName)}:</span>
                <span class="metric-badge-value">${valueDisplay}</span>
            </span>`;
        }
    </script>
</body>
</html>

